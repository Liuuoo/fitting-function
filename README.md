# 拟合函数
利用bp神经网络拟合三角函数sin(2x)+cos(5x)，并分析拟合效果
### 数据拟处理
首先，如果我们将所有数据（一个周期内的）都训练进去，是不是太没意思了，如果要真正拟合一个未知的函数，我们不一定知道其形状，值域。所以我们进行训练的数据将不仅仅局限于一个周期内的。
### 初始内容与训练集
基于数据拟处理的思想，我们不仅仅只选择一个周期内的值  

先试着拿到数据，得到sin(2x)+cos(5x)的函数图像
利用np库得到函数的精确值
```python
# 生成 1000 个 x 值，范围从 0 到 T
x_values = np.linspace(0, T, 1000)

# 计算对应的 y 值，并保留 4 位小数
y_values = np.round(np.sin(2 * x_values) + np.cos(5 * x_values), 4)
```
保存到csv文件中，当然，还需要对比得到的图像是否正确：
```python
plt.rcParams["font.sans-serif"] = ["SimHei"]  # 设置中文字体（黑体）
plt.rcParams["axes.unicode_minus"] = False  # 解决负号显示问题

# 读取 CSV 文件
df = pd.read_csv("sin_cos_training_data.csv")  # 请替换为你的文件路径
x_csv = df["x"]
y_csv = df["y"]

# 重新计算 y = sin(2x) + cos(5x)
x_calc = np.linspace(0, 2 * np.pi, 1000)
y_calc = np.sin(2 * x_calc) + np.cos(5 * x_calc)

# 绘制曲线（使用不同虚线样式）
plt.figure(figsize=(8, 4))
plt.plot(x_csv, y_csv, label="CSV 数据", color="red", linestyle="dashed")   # 红色短虚线 "--"
plt.plot(x_calc, y_calc, label="直接计算", color="blue", linestyle="dotted")  # 蓝色点状线 ":"

# 添加标签和标题
plt.xlabel("x")
plt.ylabel("y")
plt.title("CSV 数据 vs. 直接计算（不同虚线样式）")
plt.legend()
plt.grid(True)

# 保存图片
plt.savefig("comparison_plot.png", dpi=300)
plt.show()
```
执行结果如下：
![对比图](image/对比图.png)
这个对比代码后续可能还会进行重构，让它能通过出入的文件进行对比。这边先搁置，最后再来处理。当然，最后也不是拿出这里的数据进行测试，而是-20T~-10T,10T~20T的数据。  
当然，由于有限的测试集与训练集，验证集也使用测试集，我感觉问题不大。但实际上如果动态根据验证结果更改学习率，那选取不一样的验证集确实是有必要的。
### 网络结构前瞻
数据集是一千个输入对应了一千个输出，结合bp神经网络拟合手写数字的例子，我们第一步得思考这个神经网络的节点数量的安排。当然这边先用0.5学习率进行学习。  
数据很明确，一个输入一个输出，但如果仅仅如此，中间节点层数仅为一层的话我第一感觉效果会比较差。于是我考虑搭建一个两层隐藏节点的神经网络。  
这也许意味着整个网络运行效率会比较慢？之前是728*100*10次运算，这次我们也尽量将运算次数接近，如果是1*100*100,差了10倍，所以我想着再在后面插入10个节点，为第三层。  
当然上述只是猜想，如果效果出入太大再进行逻辑上的大改（结构的改变），如果效果较好就进行小改（学习率与节点数的调整）  
### 构建代码
----大体代码写完了，但有许多漏洞，生成的代码值总是为2（过大）,感觉问题出在反向传播上，下次再慢慢调